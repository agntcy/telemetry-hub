// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

package http

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/agntcy/telemetry-hub/api-layer/docs"
	"github.com/agntcy/telemetry-hub/api-layer/pkg/common"
	"github.com/agntcy/telemetry-hub/api-layer/pkg/services/clickhouse/models"
	services "github.com/agntcy/telemetry-hub/api-layer/pkg/services/interfaces"
	"github.com/rs/cors"
	httpSwagger "github.com/swaggo/http-swagger"

	// docs is generated by Swag CLI, you have to import it.

	_ "github.com/agntcy/telemetry-hub/api-layer/docs"
	"github.com/agntcy/telemetry-hub/api-layer/pkg/logger"
	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

type HttpServer struct {
	Port              int
	DataService       services.DataService
	MetricsService    services.MetricsService
	AnnotationService services.AnnotationService
	MCEServer         *MCEServer
	SignalsChannel    chan os.Signal
	BaseUrl           string
	AllowOrigins      string
	httpServer        *http.Server
	keepAliveMetric   prometheus.Counter
	AnnotationEnabled bool
}

type SimpleMessage struct {
	Message string `json:"message"`
}

type SessionID models.SessionUniqueID
type Trace models.OtelTraces
type CreateMetric models.MetricCreateRequest
type Metric models.MetricResponse

// EchoResponse represents a response for the echo endpoint.
type EchoResponse map[string]interface{}

// handleServiceError handles service errors and returns appropriate HTTP status codes with JSON responses
func (hs *HttpServer) handleServiceError(w http.ResponseWriter, err error, context string) {
	w.Header().Set("Content-Type", "application/json")

	var errorResponse ErrorResponse
	var statusCode int

	if serviceErr, ok := models.IsServiceError(err); ok {
		errorResponse.Error = true
		errorResponse.Reason = serviceErr.Error()

		switch {
		case serviceErr.IsNotFound():
			statusCode = http.StatusNotFound
		case serviceErr.IsValidation():
			statusCode = http.StatusBadRequest
		case serviceErr.IsConflict():
			statusCode = http.StatusConflict
		default:
			statusCode = http.StatusInternalServerError
		}
	} else {
		// Handle non-service errors as internal server errors
		errorResponse.Error = true
		errorResponse.Reason = err.Error()
		statusCode = http.StatusInternalServerError
	}

	errorResponse.Status = statusCode
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(errorResponse)
}

// handleJSONError returns a JSON error response with the specified status code and message
func (hs *HttpServer) handleJSONError(w http.ResponseWriter, statusCode int, message string) {
	w.Header().Set("Content-Type", "application/json")
	errorResponse := ErrorResponse{
		Error:  true,
		Status: statusCode,
		Reason: message,
	}
	w.WriteHeader(statusCode)
	json.NewEncoder(w).Encode(errorResponse)
}

// @title API-Layer API
// @version 1.0
// @description This serivce is a part of the API-Layer project. It helps to understand if the service is alive and running.
// @BasePath /

// @Summary      Get sessions
// @Description  Get sessions by start and end time
// @Tags         APIs
// @Accept       json
// @Produce      json
// @Param        start_time query string true "Start time in ISO 8601 UTC format (e.g. 2023-06-25T15:04:05Z)" example("2023-06-25T15:04:05Z")
// @Param        end_time query string true "End time in ISO 8601 UTC format (e.g. 2023-06-25T15:04:05Z)" example("2023-06-25T18:04:05Z")
// @Success		 200 {array} models.SessionsResponse "list of session IDs"
// @Failure      400 {object} string "Bad request"
// @Failure      500 {object} string "Internal server error"
// @Router       /traces/sessions [get]
func (hs *HttpServer) Sessions(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	startTime := r.URL.Query().Get(common.START_TIME)
	startTimeParsed, err := common.ParseTime(startTime)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid start_time: %v", err), http.StatusBadRequest)
		return
	}

	endTime := r.URL.Query().Get(common.END_TIME)
	endTimeParsed, err := common.ParseTime(endTime)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid end_time: %v", err), http.StatusBadRequest)
		return
	}

	includePrompts := r.URL.Query().Get(common.INCLUDE_PROMPTS)
	var sessionIDs []models.SessionUniqueID
	if includePrompts == "true" {
		sessionIDs, err = hs.DataService.GetSessionIDSWithPrompts(startTimeParsed, endTimeParsed)
	} else {
		sessionIDs, err = hs.DataService.GetSessionIDSUnique(startTimeParsed, endTimeParsed)
	}
	if err != nil {
		http.Error(w, fmt.Sprintf("Error fetching sessions: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")

	response := models.SessionsResponse{
		Data:  sessionIDs,
		Total: len(sessionIDs),
	}
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, fmt.Sprintf("Error encoding response: %v", err), http.StatusInternalServerError)
		return
	}
}

// @Summary      Get traces by session ID
// @Description  Get traces by session ID
// @Tags         APIs
// @Accept       json
// @Produce      json
// @Param        session_id path string true "Session ID" example("session_abc123")
// @Success      200 {array} Trace "List of traces for the session" example([{"trace_id": "trace_def456", "span_name": "ml_inference", "timestamp": "2023-06-25T15:30:00Z"}, {"trace_id": "trace_ghi789", "span_name": "data_processing", "timestamp": "2023-06-25T15:31:00Z"}])
// @Failure      400 {object} string "Bad request"
// @Failure      500 {object} string "Internal server error"
// @Router       /traces/session/{session_id} [get]
func (hs *HttpServer) Traces(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	vars := mux.Vars(r)
	sessionID := vars[common.SESSION_ID]
	if sessionID == "" {
		http.Error(w, "Session ID is required", http.StatusBadRequest)
		return
	}

	traces, err := hs.DataService.GetTracesBySessionID(sessionID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error fetching traces for session ID %s: %v", sessionID, err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(traces)

}

// @Summary get execution graph by SessionID
// @Description get execution graph by SessionID
// @Tags         Traces
// @Accept       json
// @Produce      json
// @Param        session_id path string true "Session ID" example("session_abc123")
// @Success 	200 {object} ExecutionGraph "Execution graph for the session" example({"session_id": "session_abc123", "nodes": [{"id": "agent_1", "name": "agent_1", "type": "service", "status": "done"}, {"id": "agent_2", "name": "agent_2", "type": "service", "status": "running"}], "edges": [{"from": "agent_1", "to": "agent_2", "execution_number": 0}], "timestamp": "2023-06-25T15:30:00Z"})
// @Failure      400 {object} ErrorResponse "Bad request"
// @Failure      500 {object} ErrorResponse "Internal server error"
// @Router       /traces/graph/{session_id} [get]
func (hs *HttpServer) GetExecutionGraphBySessionID(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		hs.handleJSONError(w, http.StatusMethodNotAllowed, "Method not allowed")
		return
	}

	vars := mux.Vars(r)
	sessionID := vars[common.SESSION_ID]
	if sessionID == "" {
		hs.handleJSONError(w, http.StatusBadRequest, "Session ID is required")
		return
	}

	graph, timestamp, err := hs.DataService.GetExecutionGraphBySessionID(sessionID)
	if err != nil {
		hs.handleServiceError(w, err, fmt.Sprintf("fetching execution graph for session ID %s", sessionID))
		return
	}
	w.Header().Set("Content-Type", "application/json")

	var graphJson map[string]interface{}
	if err := json.Unmarshal([]byte(graph), &graphJson); err != nil {
		hs.handleServiceError(w, err, "decoding graph JSON")
		return
	}

	executionGraph := models.ExecutionGraph{
		SessionID: sessionID,
		Edges:     []models.Edge{},
		Timestamp: timestamp.Format(time.RFC3339),
	}

	nodesRaw, ok := graphJson[common.NODES].(map[string]interface{})
	if !ok {
		hs.handleServiceError(w, fmt.Errorf("nodes field is not a map"), "decoding graph JSON")
		return
	}
	for _, node := range nodesRaw {
		nodeMap, ok := node.(map[string]interface{})
		if !ok {
			continue // or handle error
		}
		var typeNode = ""
		metadata := nodeMap[common.METADATA]
		if metadata != nil {
			metadataMap := metadata.(map[string]interface{})
			if metadataMap[common.TYPE] != nil {
				typeNode = metadataMap[common.TYPE].(string)
			}
		}

		statusNode := common.StateOff

		agentName := nodeMap[common.ID].(string)
		if typeNode != common.WORKFLOW {
			if agentName == common.AGENT_START_NODE || agentName == common.AGENT_END_NODE || typeNode == common.WORKFLOW {
				statusNode = common.StateNA
			} else {
				if err == nil {
					if err == nil {

						statusNode = common.StateDone
					} else {
						statusNode = common.StateRunning
					}

				}
			}
			node := models.Node{
				ID:     agentName,
				Name:   agentName,
				Type:   typeNode,
				Status: statusNode.String(),
			}
			executionGraph.Nodes = append(executionGraph.Nodes, node)
			nodeMap[agentName] = &node
		}
	}

	executionPath, err := hs.DataService.GetCallGraph(sessionID)
	if err != nil {
		logger.Zap.Error("Error", logger.Error(err))
		hs.handleServiceError(w, err, fmt.Sprintf("fetching call graph for session ID %s", sessionID))
		return
	}
	previousStep := common.AGENT_START_EVENT
	previousAgent := common.AGENT_START_NODE
	previousServiceName := common.AGENT_START_NODE
	previousPublish := ""

	i := 0
	for _, executionStep := range executionPath {

		currentSpanSplitted := strings.Split(executionStep.CurrentSpan, common.DOT)
		currentStep := currentSpanSplitted[0]
		publish := ""
		if len(currentSpanSplitted) > 1 {
			publish = currentSpanSplitted[1]
		}

		currentAgent := strings.Split(executionStep.AgentID, common.DOT)[0]
		currentServiceName := executionStep.ServiceName
		if strings.HasPrefix(previousStep, common.AUTOGEN) {
			previousAgent = executionStep.ServiceName
			previousStep = executionStep.ServiceName
		}
		if strings.HasPrefix(currentStep, common.AUTOGEN) {
			currentAgent = executionStep.ServiceName
			currentStep = executionStep.ServiceName
		}
		if currentStep != previousStep {

			fromAgent := ""

			if previousAgent == "" {
				if previousPublish == "" {
					fromAgent = previousServiceName
				} else {
					fromAgent = previousStep

				}
			} else {
				fromAgent = previousServiceName
			}

			toAgent := ""

			if currentAgent == "" {

				if publish == "" {

					toAgent = currentServiceName
				} else {

					toAgent = currentStep

				}
			} else {

				toAgent = currentServiceName
			}

			if fromAgent != "" && toAgent != "" {
				if nodesRaw[toAgent] == nil {
					node := models.Node{
						ID:     toAgent,
						Name:   toAgent,
						Status: common.StateDone.String(),
						Type:   common.TRANSPORT,
					}
					executionGraph.Nodes = append(executionGraph.Nodes, node)
					nodesRaw[toAgent] = &node
				}

				executionGraph.Edges = append(executionGraph.Edges, models.Edge{
					From:            fromAgent,
					To:              toAgent,
					ExecutionNumber: i,
				})

				i++

			}
		}

		previousPublish = publish
		previousStep = currentStep
		previousAgent = currentAgent
		previousServiceName = currentServiceName

	}

	fromAgent := ""

	if previousAgent == "" {
		if previousPublish == "" {
			fromAgent = previousServiceName
		} else {
			fromAgent = previousStep

		}
	} else {
		fromAgent = previousServiceName
	}

	executionGraph.Edges = append(executionGraph.Edges, models.Edge{
		From:            fromAgent,
		To:              common.AGENT_END_NODE,
		ExecutionNumber: i,
	})

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(executionGraph)

}

// @Summary      Get span traces by multiple session IDs
// @Description  Get span traces for multiple session IDs (comma-separated)
// @Tags         Traces
// @Accept       json
// @Produce      json
// @Param        session_ids query string true "Comma-separated list of session IDs (max 50)" example("session_abc123,session_def456,session_ghi789")
// @Success      200 {object} models.SessionSpansResponse "Map of session IDs to their traces with not found session information"
// @Failure      400 {object} ErrorResponse "Bad request"
// @Failure      500 {object} ErrorResponse "Internal server error"
// @Router       /traces/sessions/spans [get]
func (hs *HttpServer) SessionSpans(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		hs.handleJSONError(w, http.StatusMethodNotAllowed, "Method not allowed")
		return
	}

	// Get session_ids parameter
	sessionIDsParam := r.URL.Query().Get("session_ids")
	if sessionIDsParam == "" {
		hs.handleJSONError(w, http.StatusBadRequest, "session_ids parameter is required")
		return
	}

	// Parse and validate session_ids
	sessionIDs := strings.Split(sessionIDsParam, ",")

	// Trim whitespace from each session ID
	for i, id := range sessionIDs {
		sessionIDs[i] = strings.TrimSpace(id)
	}

	// Filter out empty session IDs
	var validSessionIDs []string
	for _, id := range sessionIDs {
		if id != "" {
			validSessionIDs = append(validSessionIDs, id)
		}
	}

	if len(validSessionIDs) == 0 {
		hs.handleJSONError(w, http.StatusBadRequest, "No valid session IDs provided")
		return
	}

	if len(validSessionIDs) > 50 {
		hs.handleJSONError(w, http.StatusBadRequest, "Too many session IDs provided (maximum 50)")
		return
	}

	// Get traces for all session IDs
	sessionTraces, notFoundSessionIds, err := hs.DataService.GetTracesBySessionIDs(validSessionIDs)
	if err != nil {
		hs.handleServiceError(w, err, "fetching traces for session IDs")
		return
	}

	response := models.SessionSpansResponse{
		Data:               sessionTraces,
		NotFoundSessionIds: notFoundSessionIds,
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		hs.handleServiceError(w, err, "encoding response")
		return
	}
}

// @Summary      Write session metrics
// @Description  Write session metrics to the server
// @Tags         APIs
// @Accept       json
// @Produce      json
// @Param        metric body CreateMetric true "Metric to write" example({"span_id": "span_abc123", "trace_id": "trace_def456", "session_id": "session_ghi789", "metrics": {"accuracy": "0.95", "latency_ms": "120", "error_count": "3"}, "app_name": "ml-service", "app_id": "app-001"})
// @Success      201 {object} Metric "Metric created successfully"
// @Failure      400 {object} string "Bad request"
// @Failure      500 {object} string "Internal server error"
// @Router       /metrics/session [post]
func (hs *HttpServer) WriteMetricsSession(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	hs.saveMetrics(w, r, common.METRIC_SCOPE_SESSION)

}

// @Summary      Write span metrics
// @Description  Write span metrics to the server
// @Tags         APIs
// @Accept       json
// @Produce      json
// @Param        metric body CreateMetric true "Metric to write" example({"span_id": "span_xyz789", "trace_id": "trace_uvw123", "session_id": "session_rst456", "metrics": {"response_time": "200", "cache_hit": "true", "error_type": "timeout"}, "app_name": "api-gateway", "app_id": "app-002"})
// @Success      201 {object} Metric "Metric created successfully"
// @Failure      400 {object} string "Bad request"
// @Failure      500 {object} string "Internal server error"
// @Router       /metrics/span [post]
func (hs *HttpServer) WriteMetricsSpan(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	hs.saveMetrics(w, r, common.METRIC_SCOPE_SPAN)

}

// @Summary      Get metrics by session ID
// @Description  Get metrics by session ID
// @Tags         APIs
// @Accept       json
// @Produce      json
// @Param        session_id path string true "Session ID" example("session_abc123")
// @Success      200 {array} Metric "List of metrics for the session" example([{"id": "metric_001", "span_id": "span_abc123", "trace_id": "trace_def456", "session_id": "session_abc123", "timestamp": "2023-06-25T15:30:00Z", "metrics": {"accuracy": "0.95", "latency_ms": "120"}, "app_name": "ml-service", "app_id": "app-001"}])
// @Failure      400 {object} string "Bad request"
// @Failure      500 {object} string "Internal server error"
// @Router       /metrics/session/{session_id} [get]
func (hs *HttpServer) GetMetricsSession(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	vars := mux.Vars(r)
	sessionID := vars[common.SESSION_ID]
	if sessionID == "" {
		http.Error(w, "Session ID is required", http.StatusBadRequest)
		return
	}

	metrics, err := hs.MetricsService.GetMetricsBySessionIdAndScope(sessionID, common.METRIC_SCOPE_SESSION)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error fetching metrics for session ID %s: %v", sessionID, err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(metrics)
}

// @Summary      Get metrics by span ID
// @Description  Get metrics by span ID
// @Tags         APIs
// @Accept       json
// @Produce      json
// @Param        span_id path string true "Span ID" example("span")
// @Success      200 {array} Metric "List of metrics for the span" example([{"id": "metric_001", "span_id": "span_abc123", "trace_id": "trace_def456", "session_id": "session_abc123", "timestamp": "2023-06-25T15:30:00Z", "metrics": {"accuracy": "0.95", "latency_ms": "120"}, "app_name": "ml-service", "app_id": "app-001"}])
// @Failure      400 {object} string "Bad request"
// @Failure      500 {object} string "Internal server error"
// @Router       /metrics/span/{span_id} [get]
func (hs *HttpServer) GetMetricsSpan(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	vars := mux.Vars(r)
	spanID := vars[common.SPAN_ID]
	if spanID == "" {
		http.Error(w, "Span ID is required", http.StatusBadRequest)
		return
	}

	metrics, err := hs.MetricsService.GetMetricsBySpanIdAndScope(spanID, common.METRIC_SCOPE_SPAN)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error fetching metrics for span ID %s: %v", spanID, err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(metrics)
}

func KeepAlive(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	response := SimpleMessage{Message: "I'm alive!"}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func PrometeusMetrics(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	promhttp.Handler().ServeHTTP(w, r)
}

func (hs *HttpServer) saveMetrics(w http.ResponseWriter, r *http.Request, metricScope string) {

	var metricRequest models.MetricCreateRequest
	if err := json.NewDecoder(r.Body).Decode(&metricRequest); err != nil {
		http.Error(w, fmt.Sprintf("Error decoding request body: %v", err), http.StatusBadRequest)
		return
	}

	// Convert request to metric model
	metric := metricRequest.ToMetric()
	metric.Scope = &metricScope

	createdMetric, err := hs.MetricsService.AddMetric(*metric)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error writing metric: %v", err), http.StatusInternalServerError)
		return
	}

	// Return the created metric with generated ID and timestamp
	response := createdMetric.ToResponse()
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(response)
}

func createNewCounterVec(metricName string, metricHelp string) prometheus.Counter {
	requests := prometheus.NewCounter(prometheus.CounterOpts{
		Name: metricName,
		Help: metricHelp,
	})
	requests.Inc()

	prometheus.MustRegister(requests)
	return requests
}

func (hs *HttpServer) logMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		var bodyBytes []byte
		if r.Body != nil {
			bodyBytes, _ = io.ReadAll(r.Body)
		}

		// Restore the io.ReadCloser to its original state
		r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))

		logger.Zap.Info("Started",
			logger.String("Method", r.Method),
			logger.String("Path", r.URL.Path),
			logger.String("Remote Address", r.RemoteAddr),
		)

		next.ServeHTTP(w, r)

		logger.Zap.Info("Completed",
			logger.String("Method", r.Method),
			logger.String("Path", r.URL.Path),
			logger.String("Remote Address", r.RemoteAddr),
			logger.Duration("Duration [s]", time.Since(start)),
		)

	})
}

func (hs *HttpServer) Run(ctx context.Context, wg *sync.WaitGroup) error {
	defer wg.Done()

	hs.startServer()

	logger.Zap.Info("Server is running on port", logger.Int("port", hs.Port))
	signal.Notify(hs.SignalsChannel, os.Interrupt, syscall.SIGTERM)

LOOP:
	for {
		select {
		case signal := <-hs.SignalsChannel:
			logger.Zap.Info(
				"Received signal",
				logger.String("signal", signal.String()),
			)
			break LOOP
		case <-ctx.Done():
			logger.Zap.Info(
				"Context done, terminating process grpc",
				logger.Error(ctx.Err()))
			// Call shutdown with background context
			return hs.Stop(context.Background())
		}
	}

	// stop monitoring service
	return hs.Stop(ctx)
}

func (hs *HttpServer) Stop(_ context.Context) error {
	logger.Zap.Info("Stopping Http server")
	hs.httpServer.Shutdown(context.Background())
	return nil
}

func (hs *HttpServer) startServer() {
	go func() {
		logger.Zap.Info("Starting HTTP server")

		docs.SwaggerInfo.Host = hs.BaseUrl
		hs.keepAliveMetric = createNewCounterVec("keep_alive_request", "Keep Alive Requeste, it has to be always 1")
		mux := mux.NewRouter()
		mux.Use(hs.logMiddleware)
		mux.HandleFunc("/keepAlive", KeepAlive).Methods(http.MethodGet)

		mux.HandleFunc(
			"/metrics",
			PrometeusMetrics,
		).Methods(http.MethodGet)

		mux.HandleFunc(
			"/traces/sessions",
			hs.Sessions,
		).Methods(http.MethodGet)

		mux.HandleFunc("/metrics/session", hs.WriteMetricsSession).Methods(http.MethodPost)
		mux.HandleFunc("/metrics/span", hs.WriteMetricsSpan).Methods(http.MethodPost)

		mux.HandleFunc("/metrics/session/{session_id}", hs.GetMetricsSession).Methods(http.MethodGet)
		mux.HandleFunc("/metrics/span/{span_id}", hs.GetMetricsSpan).Methods(http.MethodGet)

		mux.HandleFunc("/traces/session/{session_id}", hs.Traces)

		if hs.MCEServer != nil {
			mux.HandleFunc("/mce/metrics", hs.MCEServer.GetMetrics).Methods(http.MethodGet)
			mux.HandleFunc("/mce/status", hs.MCEServer.GetStatus).Methods(http.MethodGet)
			mux.HandleFunc("/mce/metrics/compute", hs.MCEServer.ComputeMetrics).Methods(http.MethodPost)
		}

		if hs.AnnotationService != nil && hs.AnnotationEnabled {
			annotationServer := &AnnotationServer{AnnotationService: hs.AnnotationService, Enabled: hs.AnnotationEnabled}

			mux.HandleFunc("/annotation-types", annotationServer.CreateAnnotationType).Methods(http.MethodPost)
			mux.HandleFunc("/annotation-types", annotationServer.GetAnnotationTypes).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-types/{id}", annotationServer.GetAnnotationType).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-types/{id}", annotationServer.UpdateAnnotationType).Methods(http.MethodPut)
			mux.HandleFunc("/annotation-types/{id}", annotationServer.DeleteAnnotationType).Methods(http.MethodDelete)

			mux.HandleFunc("/annotations", annotationServer.CreateAnnotation).Methods(http.MethodPost)
			mux.HandleFunc("/annotations", annotationServer.GetAnnotations).Methods(http.MethodGet)
			mux.HandleFunc("/annotations/session/{session_id}", annotationServer.GetAnnotationsBySessionID).Methods(http.MethodGet)
			mux.HandleFunc("/annotations/{id}", annotationServer.GetAnnotation).Methods(http.MethodGet)
			mux.HandleFunc("/annotations/{id}", annotationServer.UpdateAnnotation).Methods(http.MethodPut)
			mux.HandleFunc("/annotations/{id}", annotationServer.DeleteAnnotation).Methods(http.MethodDelete)

			mux.HandleFunc("/annotation-groups", annotationServer.CreateAnnotationGroup).Methods(http.MethodPost)
			mux.HandleFunc("/annotation-groups", annotationServer.GetAnnotationGroups).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-groups/{id}", annotationServer.GetAnnotationGroup).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-groups/{id}", annotationServer.UpdateAnnotationGroup).Methods(http.MethodPut)
			mux.HandleFunc("/annotation-groups/{id}", annotationServer.DeleteAnnotationGroup).Methods(http.MethodDelete)

			mux.HandleFunc("/annotation-groups/{id}/items", annotationServer.CreateAnnotationGroupItems).Methods(http.MethodPost)
			mux.HandleFunc("/annotation-groups/{id}/items", annotationServer.GetAnnotationGroupItems).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-groups/{id1}/items/{id2}", annotationServer.DeleteAnnotationGroupItem).Methods(http.MethodDelete)

			mux.HandleFunc("/annotation-groups/{id}/consensus/compute", annotationServer.ComputeConsensus).Methods(http.MethodPost)
			mux.HandleFunc("/annotation-groups/{id}/consensus", annotationServer.GetConsensusReports).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-groups/{id1}/consensus/{id2}", annotationServer.GetConsensusReport).Methods(http.MethodGet)
			mux.HandleFunc("/annotation-groups/{id1}/consensus/{id2}", annotationServer.DeleteConsensusReport).Methods(http.MethodDelete)
		}
		mux.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)
		logger.Zap.Info("Server is running on port", logger.Int("port", hs.Port))
		c := cors.New(cors.Options{
			AllowedOrigins:   []string{"http://localhost:8080"},
			AllowCredentials: true,
		})
		hs.httpServer = &http.Server{
			Addr:    fmt.Sprintf(":%d", hs.Port),
			Handler: c.Handler(mux),
		}

		if err := hs.httpServer.ListenAndServe(); err != nil {
			log.Fatal(err)
		}
	}()
}
