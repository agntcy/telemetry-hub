// Copyright AGNTCY Contributors (https://github.com/agntcy)
// SPDX-License-Identifier: Apache-2.0

package models

import (
	"encoding/json"
	"errors"
	"time"

	"gorm.io/gorm"
)

// Constants for validation
const (
	// ObservationType values as defined in ClickHouse schema
	ObservationTypeSession = "session"
	ObservationTypeTrace   = "trace"
	ObservationTypeSpan    = "span"

	// Method values for AnnotationConsensus as defined in ClickHouse schema
	ConsensusMethodMajority = "majority"
)

// ValidObservationTypes contains all valid observation types
var ValidObservationTypes = []string{
	ObservationTypeSession,
	ObservationTypeTrace,
	ObservationTypeSpan,
}

// ValidConsensusMethods contains all valid consensus methods
var ValidConsensusMethods = []string{
	ConsensusMethodMajority,
}

// IsValidObservationType checks if the given observation type is valid
func IsValidObservationType(observationType string) bool {
	for _, valid := range ValidObservationTypes {
		if observationType == valid {
			return true
		}
	}
	return false
}

// IsValidConsensusMethod checks if the given consensus method is valid
func IsValidConsensusMethod(method string) bool {
	for _, valid := range ValidConsensusMethods {
		if method == valid {
			return true
		}
	}
	return false
}

// AnnotationType represents an annotation type in the database
type AnnotationType struct {
	ID              string    `json:"id" db:"id" gorm:"column:id;primaryKey;<-:false"`
	Name            string    `json:"name" db:"name" gorm:"column:name"`
	Type            string    `json:"type" db:"type" gorm:"column:type"` // numerical, categorical, boolean
	NumericalMin    *float64  `json:"numerical_min,omitempty" db:"numerical_min" gorm:"column:numerical_min"`
	NumericalMax    *float64  `json:"numerical_max,omitempty" db:"numerical_max" gorm:"column:numerical_max"`
	CategoricalList []string  `json:"categorical_list,omitempty" db:"categorical_list" gorm:"column:categorical_list;type:Array(String)"`
	CreationDate    time.Time `json:"creation_date" db:"creation_date" gorm:"column:creation_date;<-:false"`
	UpdateDate      time.Time `json:"update_date" db:"update_date" gorm:"column:update_date;<-:false"`
	Discontinued    bool      `json:"discontinued" db:"discontinued" gorm:"column:discontinued"`
	Comment         *string   `json:"comment,omitempty" db:"comment" gorm:"column:comment"`
}

// BeforeCreate is a GORM hook that runs before creating an AnnotationType
func (at *AnnotationType) BeforeCreate(tx *gorm.DB) error {
	// ID is auto-generated by ClickHouse using generateUUIDv4()
	// creation_date and update_date are auto-generated by ClickHouse using now()
	return nil
}

// BeforeUpdate is a GORM hook that runs before updating an AnnotationType
func (at *AnnotationType) BeforeUpdate(tx *gorm.DB) error {
	at.UpdateDate = time.Now()
	return nil
}

// AnnotationTypeCreate represents the request payload for creating an annotation type
type AnnotationTypeCreate struct {
	Name            string   `json:"name"`
	Type            string   `json:"type"` // numerical, categorical, boolean
	NumericalMin    *float64 `json:"numerical_min,omitempty"`
	NumericalMax    *float64 `json:"numerical_max,omitempty"`
	CategoricalList []string `json:"categorical_list,omitempty"`
	Comment         *string  `json:"comment,omitempty"`
}

// AnnotationTypeUpdate represents the request payload for updating an annotation type
type AnnotationTypeUpdate struct {
	Name         *string `json:"name,omitempty"`
	Comment      *string `json:"comment,omitempty"`
	Discontinued *bool   `json:"discontinued,omitempty"`
}

// AnnotationTypeResponse represents the response for annotation type operations
type AnnotationTypeResponse struct {
	ID              string    `json:"id"`
	Name            string    `json:"name"`
	Type            string    `json:"type"`
	NumericalMin    *float64  `json:"numerical_min,omitempty"`
	NumericalMax    *float64  `json:"numerical_max,omitempty"`
	CategoricalList []string  `json:"categorical_list,omitempty"`
	CreationDate    time.Time `json:"creation_date"`
	UpdateDate      time.Time `json:"update_date"`
	Discontinued    bool      `json:"discontinued"`
	Comment         *string   `json:"comment,omitempty"`
}

// ToResponse converts AnnotationType to AnnotationTypeResponse
func (at *AnnotationType) ToResponse() AnnotationTypeResponse {
	return AnnotationTypeResponse{
		ID:              at.ID,
		Name:            at.Name,
		Type:            at.Type,
		NumericalMin:    at.NumericalMin,
		NumericalMax:    at.NumericalMax,
		CategoricalList: at.CategoricalList,
		CreationDate:    at.CreationDate,
		UpdateDate:      at.UpdateDate,
		Discontinued:    at.Discontinued,
		Comment:         at.Comment,
	}
}

// ToAnnotationType converts AnnotationTypeCreate to AnnotationType
func (atc *AnnotationTypeCreate) ToAnnotationType() *AnnotationType {
	return &AnnotationType{
		Name:            atc.Name,
		Type:            atc.Type,
		NumericalMin:    atc.NumericalMin,
		NumericalMax:    atc.NumericalMax,
		CategoricalList: atc.CategoricalList,
		Discontinued:    false,
		Comment:         atc.Comment,
	}
}

// Annotation represents an annotation in the database
type Annotation struct {
	ID               string     `json:"id" db:"id" gorm:"column:id;primaryKey;<-:false"`
	AnnotationTypeID string     `json:"annotation_type_id" db:"annotation_type_id"`
	GroupItemID      string     `json:"group_item_id" db:"group_item_id"`
	ReviewerID       string     `json:"reviewer_id" db:"reviewer_id"`
	ObservationID    string     `json:"observation_id" db:"observation_id"`
	ObservationType  string     `json:"observation_type" db:"observation_type"` // session, trace, span
	ObservationKind  string     `json:"observation_kind" db:"observation_kind"` // session, llm, agent, tool ...
	SessionID        string     `json:"session_id" db:"session_id"`
	Input            string     `json:"input" db:"input"`
	InputType        string     `json:"input_type" db:"input_type"` // json, text, image ...
	Output           string     `json:"output" db:"output"`
	OutputType       string     `json:"output_type" db:"output_type"` // json, text, image ...
	ExpectedOutput   *string    `json:"expected_output,omitempty" db:"expected_output"`
	AnnotationValue  string     `json:"annotation_value,omitempty" db:"annotation_value" gorm:"column:annotation_value"`
	CreationDate     time.Time  `json:"creation_date" db:"creation_date" gorm:"<-:false"`
	UpdateDate       time.Time  `json:"update_date" db:"update_date" gorm:"<-:false"`
	AcceptanceID     *string    `json:"acceptance_id,omitempty" db:"acceptance_id"`
	AcceptanceDate   *time.Time `json:"acceptance_date,omitempty" db:"acceptance_date"`
	Acceptance       *uint8     `json:"acceptance,omitempty" db:"acceptance"`
	Comment          *string    `json:"comment,omitempty" db:"comment"`
}

// BeforeCreate is a GORM hook that runs before creating an Annotation
func (a *Annotation) BeforeCreate(tx *gorm.DB) error {
	// Validate observation_type
	if !IsValidObservationType(a.ObservationType) {
		return errors.New("invalid observation_type: must be one of 'session', 'trace', 'span'")
	}
	// ID is auto-generated by ClickHouse using generateUUIDv4()
	// creation_date and update_date are auto-generated by ClickHouse using now()
	return nil
}

// BeforeUpdate is a GORM hook that runs before updating an Annotation
func (a *Annotation) BeforeUpdate(tx *gorm.DB) error {
	a.UpdateDate = time.Now()
	return nil
}

// AnnotationCreate represents the request payload for creating an annotation
type AnnotationCreate struct {
	AnnotationTypeID string  `json:"annotation_type_id"`
	GroupItemID      string  `json:"group_item_id"`
	ReviewerID       string  `json:"reviewer_id"`
	ObservationID    string  `json:"observation_id"`
	ObservationType  string  `json:"observation_type"` // session, trace, span
	ObservationKind  string  `json:"observation_kind"` // session, llm, agent, tool ...
	SessionID        string  `json:"session_id"`
	Input            string  `json:"input"`
	InputType        string  `json:"input_type"` // json, text, image ...
	Output           string  `json:"output"`
	OutputType       string  `json:"output_type"` // json, text, image ...
	ExpectedOutput   *string `json:"expected_output,omitempty"`
	AnnotationValue  string  `json:"annotation_value,omitempty"`
	Comment          *string `json:"comment,omitempty"`
}

// AnnotationUpdate represents the request payload for updating an annotation
type AnnotationUpdate struct {
	AnnotationValue string  `json:"annotation_value,omitempty"`
	ExpectedOutput  *string `json:"expected_output,omitempty"`
	Comment         *string `json:"comment,omitempty"`
	Acceptance      *uint8  `json:"acceptance,omitempty"`
	AcceptanceID    *string `json:"acceptance_id,omitempty"`
}

// AnnotationResponse represents the response for annotation operations
type AnnotationResponse struct {
	ID               string     `json:"id"`
	AnnotationTypeID string     `json:"annotation_type_id"`
	GroupItemID      string     `json:"group_item_id"`
	ReviewerID       string     `json:"reviewer_id"`
	ObservationID    string     `json:"observation_id"`
	ObservationType  string     `json:"observation_type"`
	ObservationKind  string     `json:"observation_kind"`
	SessionID        string     `json:"session_id"`
	Input            string     `json:"input"`
	InputType        string     `json:"input_type"`
	Output           string     `json:"output"`
	OutputType       string     `json:"output_type"`
	ExpectedOutput   *string    `json:"expected_output,omitempty"`
	AnnotationValue  string     `json:"annotation_value,omitempty"`
	CreationDate     time.Time  `json:"creation_date"`
	UpdateDate       time.Time  `json:"update_date"`
	AcceptanceID     *string    `json:"acceptance_id,omitempty"`
	AcceptanceDate   *time.Time `json:"acceptance_date,omitempty"`
	Acceptance       *uint8     `json:"acceptance,omitempty"`
	Comment          *string    `json:"comment,omitempty"`
}

// ToResponse converts Annotation to AnnotationResponse
func (a *Annotation) ToResponse() AnnotationResponse {
	return AnnotationResponse{
		ID:               a.ID,
		AnnotationTypeID: a.AnnotationTypeID,
		GroupItemID:      a.GroupItemID,
		ReviewerID:       a.ReviewerID,
		ObservationID:    a.ObservationID,
		ObservationType:  a.ObservationType,
		ObservationKind:  a.ObservationKind,
		SessionID:        a.SessionID,
		Input:            a.Input,
		InputType:        a.InputType,
		Output:           a.Output,
		OutputType:       a.OutputType,
		ExpectedOutput:   a.ExpectedOutput,
		AnnotationValue:  a.AnnotationValue,
		CreationDate:     a.CreationDate,
		UpdateDate:       a.UpdateDate,
		AcceptanceID:     a.AcceptanceID,
		AcceptanceDate:   a.AcceptanceDate,
		Acceptance:       a.Acceptance,
		Comment:          a.Comment,
	}
}

// ToAnnotation converts AnnotationCreate to Annotation
func (ac *AnnotationCreate) ToAnnotation() *Annotation {
	return &Annotation{
		AnnotationTypeID: ac.AnnotationTypeID,
		GroupItemID:      ac.GroupItemID,
		ReviewerID:       ac.ReviewerID,
		ObservationID:    ac.ObservationID,
		ObservationType:  ac.ObservationType,
		ObservationKind:  ac.ObservationKind,
		SessionID:        ac.SessionID,
		Input:            ac.Input,
		InputType:        ac.InputType,
		Output:           ac.Output,
		OutputType:       ac.OutputType,
		ExpectedOutput:   ac.ExpectedOutput,
		AnnotationValue:  ac.AnnotationValue,
		Comment:          ac.Comment,
	}
}

// Validate validates an AnnotationCreate request
func (ac *AnnotationCreate) Validate() error {
	if !IsValidObservationType(ac.ObservationType) {
		return errors.New("invalid observation_type: must be one of 'session', 'trace', 'span'")
	}
	return nil
}

// AnnotationGroup represents an annotation group in the database
type AnnotationGroup struct {
	ID                string   `json:"id" db:"id" gorm:"column:id;primaryKey;<-:false"`
	Name              string   `json:"name" db:"name" gorm:"column:name"`
	AnnotationTypeIDs []string `json:"annotation_type_ids" db:"annotation_type_ids" gorm:"column:annotation_type_ids;type:Array(String)"`
	MinReviews        int      `json:"min_reviews" db:"min_reviews" gorm:"column:min_reviews"`
	MaxReviews        int      `json:"max_reviews" db:"max_reviews" gorm:"column:max_reviews"`
	MaxReport         int      `json:"max_report" db:"max_report" gorm:"column:max_report;default:5"`
	Discontinued      bool     `json:"discontinued" db:"discontinued" gorm:"column:discontinued"`
	Comment           *string  `json:"comment,omitempty" db:"comment" gorm:"column:comment"`
}

// BeforeCreate is a GORM hook that runs before creating an AnnotationGroup
func (ag *AnnotationGroup) BeforeCreate(tx *gorm.DB) error {
	// ID is auto-generated by ClickHouse using generateUUIDv4()
	return nil
}

// AnnotationGroupCreate represents the request payload for creating an annotation group
type AnnotationGroupCreate struct {
	Name              string   `json:"name"`
	AnnotationTypeIDs []string `json:"annotation_type_ids"`
	MinReviews        int      `json:"min_reviews"`
	MaxReviews        int      `json:"max_reviews"`
	MaxReport         *int     `json:"max_report,omitempty"`
	Comment           *string  `json:"comment,omitempty"`
}

// AnnotationGroupUpdate represents the request payload for updating an annotation group
type AnnotationGroupUpdate struct {
	Name         *string `json:"name,omitempty"`
	Comment      *string `json:"comment,omitempty"`
	Discontinued *bool   `json:"discontinued,omitempty"`
	MinReviews   *int    `json:"min_reviews,omitempty"`
	MaxReviews   *int    `json:"max_reviews,omitempty"`
	MaxReport    *int    `json:"max_report,omitempty"`
}

// AnnotationGroupResponse represents the response for annotation group operations
type AnnotationGroupResponse struct {
	ID                string   `json:"id"`
	Name              string   `json:"name"`
	AnnotationTypeIDs []string `json:"annotation_type_ids"`
	MinReviews        int      `json:"min_reviews"`
	MaxReviews        int      `json:"max_reviews"`
	MaxReport         int      `json:"max_report"`
	Discontinued      bool     `json:"discontinued"`
	Comment           *string  `json:"comment,omitempty"`
}

// ToResponse converts AnnotationGroup to AnnotationGroupResponse
func (ag *AnnotationGroup) ToResponse() AnnotationGroupResponse {
	return AnnotationGroupResponse{
		ID:                ag.ID,
		Name:              ag.Name,
		AnnotationTypeIDs: ag.AnnotationTypeIDs,
		MinReviews:        ag.MinReviews,
		MaxReviews:        ag.MaxReviews,
		MaxReport:         ag.MaxReport,
		Discontinued:      ag.Discontinued,
		Comment:           ag.Comment,
	}
}

// ToAnnotationGroup converts AnnotationGroupCreate to AnnotationGroup
func (agc *AnnotationGroupCreate) ToAnnotationGroup() *AnnotationGroup {
	maxReport := 5 // Default value
	if agc.MaxReport != nil && *agc.MaxReport > 0 {
		maxReport = *agc.MaxReport
	}

	return &AnnotationGroup{
		Name:              agc.Name,
		AnnotationTypeIDs: agc.AnnotationTypeIDs,
		MinReviews:        agc.MinReviews,
		MaxReviews:        agc.MaxReviews,
		MaxReport:         maxReport,
		Discontinued:      false,
		Comment:           agc.Comment,
	}
}

// AnnotationGroupItem represents an annotation group item in the database
type AnnotationGroupItem struct {
	ID           string    `json:"id" db:"id" gorm:"column:id;primaryKey;<-:false"`
	GroupID      string    `json:"group_id" db:"group_id"`
	SessionID    string    `json:"session_id" db:"session_id"`
	CreationDate time.Time `json:"creation_date" db:"creation_date" gorm:"column:creation_date;<-:false"`
}

// BeforeCreate is a GORM hook that runs before creating an AnnotationGroupItem
func (agi *AnnotationGroupItem) BeforeCreate(tx *gorm.DB) error {
	// ID is auto-generated by ClickHouse using generateUUIDv4()
	return nil
}

// AnnotationGroupItemCreate represents the request payload for creating annotation group items
type AnnotationGroupItemCreate struct {
	SessionIDs []string `json:"session_ids"`
}

// AnnotationGroupItemResponse represents the response for annotation group item operations
type AnnotationGroupItemResponse struct {
	ID           string    `json:"id"`
	GroupID      string    `json:"group_id"`
	SessionID    string    `json:"session_id"`
	CreationDate time.Time `json:"creation_date"`
}

// ToResponse converts AnnotationGroupItem to AnnotationGroupItemResponse
func (agi *AnnotationGroupItem) ToResponse() AnnotationGroupItemResponse {
	return AnnotationGroupItemResponse{
		ID:           agi.ID,
		GroupID:      agi.GroupID,
		SessionID:    agi.SessionID,
		CreationDate: agi.CreationDate,
	}
}

// AnnotationTypeStatistic represents statistics for a specific annotation type and observation type combination
type AnnotationTypeStatistic struct {
	AnnotationTypeID   string        `json:"annotation_type_id"`
	AnnotationTypeName string        `json:"annotation_type_name"`
	AnnotationTypeType string        `json:"annotation_type_type"`
	ObservationType    string        `json:"observation_type"`
	SessionsCount      int           `json:"sessions_count"`
	Consensus          int           `json:"consensus"`
	NoConsensus        int           `json:"no_consensus"`
	QualityScore       float64       `json:"quality_score"`
	ConsensusRate      float64       `json:"consensus_rate"`
	ConsensusValues    []interface{} `json:"consensus_values,omitempty"`
}

// ConsensusValue represents a consensus value for a specific session and observation
type ConsensusValue struct {
	SessionID     string      `json:"session_id"`
	ObservationID string      `json:"observation_id"`
	Value         interface{} `json:"value"`
}

// NoConsensusValue represents annotation values where no consensus was reached
type NoConsensusValue struct {
	SessionID     string        `json:"session_id"`
	ObservationID string        `json:"observation_id"`
	Values        []interface{} `json:"values"`
}

// AnnotationConsensus represents an annotation consensus report
type AnnotationConsensus struct {
	ID                       string          `json:"id" db:"id" gorm:"column:id;primaryKey;<-:false"`
	GroupID                  string          `json:"group_id" db:"group_id"`
	Method                   string          `json:"method" db:"method" gorm:"column:method"`
	Valid                    bool            `json:"valid" db:"valid"`
	QualityScore             float64         `json:"quality_score" db:"quality_score"`
	AnnotationStatistics     *JSONRawMessage `json:"annotation_statistics" db:"annotation_statistics"`
	AnnotationTypeStatistics *JSONRawMessage `json:"annotation_type_statistics" db:"annotation_type_statistics"`
	ConsensusValues          *JSONRawMessage `json:"consensus_values" db:"consensus_values"`
	NoConsensusValues        *JSONRawMessage `json:"no_consensus_values" db:"no_consensus_values"`
	ReviewersQualityScore    *JSONRawMessage `json:"reviewers_quality_score" db:"reviewers_quality_score"`
	ReviewersStats           *JSONRawMessage `json:"reviewers_stats" db:"reviewers_stats"`
	CreationDate             time.Time       `json:"creation_date" db:"creation_date" gorm:"column:creation_date;<-:false"`
}

// BeforeCreate is a GORM hook that runs before creating an AnnotationConsensus
func (ac *AnnotationConsensus) BeforeCreate(tx *gorm.DB) error {
	// Validate method
	if !IsValidConsensusMethod(ac.Method) {
		return errors.New("invalid method: must be 'majority'")
	}
	// ID and creation_date are auto-generated by ClickHouse using generateUUIDv4() and now()
	return nil
}

// AnnotationConsensusResponse represents the response for annotation consensus operations
type AnnotationConsensusResponse struct {
	ID                       string                 `json:"id"`
	GroupID                  string                 `json:"group_id"`
	Method                   string                 `json:"method"`
	Valid                    bool                   `json:"valid"`
	QualityScore             float64                `json:"quality_score"`
	AnnotationStatistics     map[string]interface{} `json:"annotation_statistics"`
	AnnotationTypeStatistics []interface{}          `json:"annotation_type_statistics"`
	ConsensusValues          []interface{}          `json:"consensus_values"`
	NoConsensusValues        []interface{}          `json:"no_consensus_values"`
	ReviewersQualityScore    map[string]interface{} `json:"reviewers_quality_score"`
	ReviewersStats           map[string]interface{} `json:"reviewers_stats"`
	CreationDate             time.Time              `json:"creation_date"`
}

// ToResponse converts AnnotationConsensus to AnnotationConsensusResponse
func (ac *AnnotationConsensus) ToResponse() AnnotationConsensusResponse {
	// Helper function to convert JSONRawMessage to map[string]interface{}
	convertJSONRawToMap := func(raw *JSONRawMessage) map[string]interface{} {
		if raw == nil {
			return nil
		}
		var result map[string]interface{}
		if err := json.Unmarshal([]byte(*raw), &result); err != nil {
			return nil
		}
		return result
	}

	// Helper function to convert JSONRawMessage to []interface{}
	convertJSONRawToSlice := func(raw *JSONRawMessage) []interface{} {
		if raw == nil {
			return nil
		}
		var result []interface{}
		if err := json.Unmarshal([]byte(*raw), &result); err != nil {
			return nil
		}
		return result
	}

	return AnnotationConsensusResponse{
		ID:                       ac.ID,
		GroupID:                  ac.GroupID,
		Method:                   ac.Method,
		Valid:                    ac.Valid,
		QualityScore:             ac.QualityScore,
		AnnotationStatistics:     convertJSONRawToMap(ac.AnnotationStatistics),
		AnnotationTypeStatistics: convertJSONRawToSlice(ac.AnnotationTypeStatistics),
		ConsensusValues:          convertJSONRawToSlice(ac.ConsensusValues),
		NoConsensusValues:        convertJSONRawToSlice(ac.NoConsensusValues),
		ReviewersQualityScore:    convertJSONRawToMap(ac.ReviewersQualityScore),
		ReviewersStats:           convertJSONRawToMap(ac.ReviewersStats),
		CreationDate:             ac.CreationDate,
	}
}

// PaginatedResponse represents a paginated response
type PaginatedResponse struct {
	Page    int         `json:"page"`
	Limit   int         `json:"limit"`
	Total   int         `json:"total"`
	HasNext bool        `json:"has_next"`
	HasPrev bool        `json:"has_prev"`
	Data    interface{} `json:"data"`
}

// AnnotationDataset represents an annotation dataset
type AnnotationDataset struct {
	ID           string    `json:"id" gorm:"primaryKey;column:id"`
	Name         string    `json:"name" gorm:"column:name"`
	Tags         []string  `json:"tags" gorm:"column:tags;type:Array(String)"`
	CreationDate time.Time `json:"creation_date" gorm:"column:creation_date"`
}

// TableName returns the table name for AnnotationDataset
func (AnnotationDataset) TableName() string {
	return "annotation_datasets"
}

// AnnotationDatasetCreate represents the request to create a dataset
type AnnotationDatasetCreate struct {
	Name string   `json:"name" binding:"required"`
	Tags []string `json:"tags,omitempty"`
}

// ToAnnotationDataset converts create request to dataset model
func (adc *AnnotationDatasetCreate) ToAnnotationDataset() *AnnotationDataset {
	if adc.Tags == nil {
		adc.Tags = []string{}
	}
	return &AnnotationDataset{
		Name: adc.Name,
		Tags: adc.Tags,
	}
}

// AnnotationDatasetResponse represents the response when returning a dataset
type AnnotationDatasetResponse struct {
	ID           string    `json:"id"`
	Name         string    `json:"name"`
	Tags         []string  `json:"tags"`
	CreationDate time.Time `json:"creation_date"`
	CountItems   *int      `json:"count_items,omitempty"`
}

// ToResponse converts dataset model to response
func (ad *AnnotationDataset) ToResponse() AnnotationDatasetResponse {
	return AnnotationDatasetResponse{
		ID:           ad.ID,
		Name:         ad.Name,
		Tags:         ad.Tags,
		CreationDate: ad.CreationDate,
	}
}

// ToResponseWithCount converts dataset model to response with item count
func (ad *AnnotationDataset) ToResponseWithCount(count int) AnnotationDatasetResponse {
	response := ad.ToResponse()
	response.CountItems = &count
	return response
}

// AnnotationDatasetItem represents an item in a dataset
type AnnotationDatasetItem struct {
	ID             string     `json:"id" gorm:"primaryKey;column:id"`
	DatasetID      string     `json:"dataset_id" gorm:"column:dataset_id"`
	SessionID      string     `json:"session_id" gorm:"column:session_id"`
	SessionDate    *time.Time `json:"session_date" gorm:"column:session_date"`
	Input          string     `json:"input" gorm:"column:input"`
	Output         string     `json:"output" gorm:"column:output"`
	ExpectedOutput string     `json:"expected_output" gorm:"column:expected_output"`
	Tags           []string   `json:"tags" gorm:"column:tags;type:Array(String)"`
	CreationDate   time.Time  `json:"creation_date" gorm:"column:creation_date"`
}

// TableName returns the table name for AnnotationDatasetItem
func (AnnotationDatasetItem) TableName() string {
	return "annotation_dataset_items"
}

// AnnotationDatasetItemCreate represents the request to create a dataset item
type AnnotationDatasetItemCreate struct {
	SessionID      string     `json:"session_id" binding:"required"`
	SessionDate    *time.Time `json:"session_date,omitempty"`
	Input          string     `json:"input" binding:"required"`
	Output         string     `json:"output" binding:"required"`
	ExpectedOutput string     `json:"expected_output" binding:"required"`
	Tags           []string   `json:"tags,omitempty"`
}

// ToAnnotationDatasetItem converts create request to dataset item model
func (adic *AnnotationDatasetItemCreate) ToAnnotationDatasetItem(datasetID string) *AnnotationDatasetItem {
	if adic.Tags == nil {
		adic.Tags = []string{}
	}
	return &AnnotationDatasetItem{
		DatasetID:      datasetID,
		SessionID:      adic.SessionID,
		SessionDate:    adic.SessionDate,
		Input:          adic.Input,
		Output:         adic.Output,
		ExpectedOutput: adic.ExpectedOutput,
		Tags:           adic.Tags,
	}
}

// ImportResponse represents the response for import operations
type ImportResponse struct {
	Name   string         `json:"name"`
	Status ImportStatus   `json:"status"`
	Errors map[int]string `json:"errors,omitempty"`
}

// ImportStatus represents the status of an import operation
type ImportStatus struct {
	State string `json:"state"`
}

// Import status constants
const (
	ImportStateCompleted = "COMPLETED"
	ImportStateFailed    = "FAILED"
	ImportStatePartial   = "PARTIAL"
)

// DatasetItemsResponse represents the response for getting dataset items
type DatasetItemsResponse struct {
	Data            map[string]AnnotationDatasetItem `json:"data"`
	NotFoundItemIDs []string                         `json:"notfound_item_ids"`
}